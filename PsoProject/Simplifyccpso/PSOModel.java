/**
 * <p>Title: PSOModel.java </p>
 * <p>Description: CCPSO2 - Cooperatively Coevolving PSO 2</p>
 * <p>Copyright: Copyright (c) 25/03/2009</p>
 * <p>Company: RMIT CS</p>
 * @author Xiaodong Li (xiaodong.li@rmit.edu.au)
 * @version 1.0
 * Usage: To use this program, you need to install RePast 3.1
 * which can be found from: http://repast.sourceforge.net/repast_3/download.html
 */
 
import java.util.*;
import java.io.*;
import uchicago.src.sim.engine.SimModelImpl;

import cern.jet.random.*;
import uchicago.src.sim.util.Random;
import uchicago.src.sim.engine.*;
import uchicago.src.sim.analysis.*;
import uchicago.src.sim.analysis.plot.OpenGraph;
import uchicago.src.reflector.*;


// Simulation models should extend SimModelImpl which does some basic setup
// and allows a controller easy access to a simulations initial parameters.
public class PSOModel extends SimModelImpl {

  // -------------------------------------------------------------- Members

  /** A schedule associated with this model **/
  protected Schedule schedule;

  /** A list of all existing swarms **/
  protected ArrayList swarmList;
  
  /** A DataRecorder allows data generated by a simulation to be written to a file **/
  protected DataRecorder recorder;

  /** A plot to display particles in the decision space  **/
  protected Plot aPlot;
  
  /** A graph to display the fitness at each iteration**/
  protected OpenSequenceGraph graph; 
  
  /** An array contains the values for all dimensions **/
  private double[] present;

  /** An array for storing random selected subcomponents from other swarms **/
  private double[] randomPresent;
  
  /** The current fitness value **/
  private double fitnessValue;
 
  /** The current fitness value **/
  private double randomPresentFitValue;
 
  /** The array stores the loccation of the global best **/
  private double[] gBest;  
  
  /** The array stores the loccation of the global best **/
  private double[] prevGBest;  

  /** The difference between gBest and the prevGBest **/
  private double[] deltaGBest;

  /** The value of the global best **/
  private double gBestValue = 1.7976931348623157E308;

  /** The value of the global best **/
  private double prevGBestValue = 1.7976931348623157E308;

  /** The difference between gBestValue and the previous iteration's gBestValue **/
  private double deltaGBestValue = 0.0;

  /** The array stores the locations of the all individuals **/
  private double[][] pop;

  /** The array stores the locations of the all pBests **/
  private double[][] popPBest;  

  /** The array stores the velocities of the all individuals **/
  private double[][] v;
  
  /** The index for all dimensions **/
  private int[] index;
   
  /** A list of all indices for all dimensions **/
  protected ArrayList indexList, sortedIndexList;
  
  /** Number of evaluations **/
  protected int numEvals = 0;
  
  /** Number of run **/
  protected int run = 50;
  
  BufferedWriter out, summary;   //output writer for all data (out) and selected results (summary) at certain evaluation numbers. 
  
  /* rotation matrix */
  double[][] rotationmatrix = null;
    
  /* F7 FastFractal "DoubleDip" Function */
  private FastFractal f7;
  
  private int maxDims = 1000;  

  /* parameters accessor methods */
  private int numParticles = 50;
  private int numSwarms = 1;
  
  /* please click the "reset" button to choose different settings for ranges and v_max */
  private double leftRange = -100.0; //Rastrigin
  private double rightRange = 100.0;
  private double velocityMax = 100.0;
  private int maxIterations = 5000;
  private int maxNumEvals = 200000;
  private int interval = maxNumEvals/100;
  private int dimension = 2;  
  private String function = "Sphere"; // "RRastrigin";
  private int functionID; 
  public String method = "CCPSO_Sync"; 
  private double ticks = 0;
  private int swarmDim = dimension/numSwarms;
  private int resizeIters = 500; // every this number of iterations, resize the swarm 
 
  private boolean BATCH = false;  // BATCH or graph mode
  private boolean RGROUPING = true; // random grouping for the swarmList or not
  private boolean OUTGBEST = false; // output sequential data (of gBestValue) for plotting
  private boolean ROTATIONFLAG = true; // call the rotation matrix generation function
  private boolean RESIZE = false; // resize the swarm size (manually from large to small) and the number of swarms
  private boolean GROUPBYDELTA = false; // ranked grouping, ie, grouping based on sorted dimensions 
  private boolean ADAPTIVEGROUPSIZE = false; // using adaptive group sizes scheme
  
  private cern.jet.random.engine.RandomEngine generator;
  private int swarmDimsArray[] = {2,5,10,50,100,250,500,1000}; // for randomly selecting swarmDim
  //private int swarmDimsArray[] = {5,10,25,50,100,250};
  private int swarmDimsArraySize = 6; // 5 for 100 dimensions, 6 for 500 and 1000 dimension
  //private int swarmDimsArraySize = 7; // for 1500 or 2000 dimensions
  // ---------------------------------------------------------- Constructor(s)

  public PSOModel() {
    
    Vector v = new Vector();
    //v.add("CCPSO_Sk");
    //v.add("CCPSO_Sk2");
    v.add("CCPSO_Ring");
    v.add("CCPSO_Sync");
    v.add("CCPSO_Barebone");
    v.add("CCPSO_Gaussian");
    v.add("CCPSO_Cauchy");
         
    ListPropertyDescriptor pd = new ListPropertyDescriptor("Method", v);
    descriptors.put("Method", pd);
        
    Vector v2 = new Vector();
    v2.add("Parabola");
    v2.add("Sphere");
/*    v2.add("Himmelblau");
    v2.add("Rastrigin");
    v2.add("RRastrigin");
    v2.add("Griewank");
    v2.add("RGriewank");
    v2.add("Ackley");
    v2.add("RAckley");
    v2.add("Schwefel");
    v2.add("RSchwefel");
    v2.add("Rosenbrock");
    v2.add("RRosenbrock");
    v2.add("Quadric");
    v2.add("RQuadric");
    v2.add("HyperEllipsoid");
    v2.add("RHyperEllipsoid");
*/    v2.add("ShiftedSphere");
    v2.add("SchwefelProblem");
    v2.add("ShiftedRosenbrock");
    v2.add("ShiftedRastrigin");
    v2.add("ShiftedGriewank");
    v2.add("ShiftedAckley");
    v2.add("FastFractal");
    v2.add("ShiftedRotatedRastrigin");
    v2.add("ShiftedRotatedRosenbrock");
    v2.add("ShiftedRotatedGriewank");
    v2.add("ShiftedRotatedAckley");
    ListPropertyDescriptor pd2 = new ListPropertyDescriptor("Function", v2);
    descriptors.put("Function", pd2);
    
  }


  // ------------------------------------------------------------- Methods

  /** Every model must have begin() and setup() methods (required for implementing
    * the SimModel inteface).
    * begin() should intialize the model for the start of a run. Consequently,
    * the build* methods are called here, and any displays are displayed. build()
    * is called whenever the start button (or the step button if the run has
    * not yet started) is clicked.
    */
  public void begin() {
  
    // initialize Random.uniform
    Random.createUniform();  
    Random.createNormal(0,1.0);
    
    generator = new cern.jet.random.engine.MersenneTwister(new java.util.Date());
    //double cauchy = Distributions.nextCauchy(generator);
    
    // set the function ranges, velocityMax etc to the chosen one
    setFunctionParams();
  
    // Create an array list containing all swarms;
    swarmList = new ArrayList();         
    
    // Create an array list containing all dimIndex instances
    indexList = new ArrayList();
    sortedIndexList = new ArrayList();
    
    // gBest[] and gBest value
    gBest = new double[dimension];
    prevGBest = new double[dimension];
    deltaGBest = new double[dimension];
    present = new double[dimension];
    randomPresent = new double[dimension];
    pop = new double[numParticles][dimension];
    popPBest = new double[numParticles][dimension];
    v = new double[numParticles][dimension];   
    
    if (getFunction().equals("ShiftedSphere")) 
        functionID = 0;
    else if (getFunction().equals("SchwefelProblem")) 
        functionID = 1;
    else if (getFunction().equals("ShiftedRosenbrock") || getFunction().equals("ShiftedRotatedRosenbrock")) 
        functionID = 2;
    else if (getFunction().equals("ShiftedRastrigin") || getFunction().equals("ShiftedRotatedRastrigin")) 
        functionID = 3;     
    else if (getFunction().equals("ShiftedGriewank") || getFunction().equals("ShiftedRotatedGriewank")) 
        functionID = 4;
    else if (getFunction().equals("ShiftedAckley") || getFunction().equals("ShiftedRotatedAckley")) 
        functionID = 5;
    else if (getFunction().equals("FastFractal")) 
        functionID = 6;
                
    gBestValue = 1.7976931348623157E308;
    prevGBestValue = 1.7976931348623157E308;
    fitnessValue = 1.7976931348623157E308;
    randomPresentFitValue = 1.7976931348623157E308;
    
    numEvals = 0; // counting starts from 0
    
    // generate rotation matrix for rotated functions
    if (ROTATIONFLAG == true)
    {
        rotationmatrix = new double[dimension][dimension];
        rotationmatrix = generateRotationMatrix(dimension); 
    }
    //pick a random swarm dimension, then decide on numSwarms
    if (ADAPTIVEGROUPSIZE == true)
    {
        int randSelect = (int)(Math.floor(Math.random() * swarmDimsArraySize));  //select a random swarmDim
        swarmDim = swarmDimsArray[randSelect];  // put this line back when removing the line below   
    }    
    
    //numSwarms = dimension/swarmDim;   
    swarmDim = dimension/numSwarms;
    interval = maxNumEvals/100;
    
    if (OUTGBEST == true)
    {
        try
        { 
            out = new BufferedWriter(new FileWriter(getFunction()+getDimension()+"d"+".rst", true));  //append mode     
            summary = new BufferedWriter(new FileWriter(getFunction()+getDimension()+"dSum"+".rst", true));  //append mode  
        }
        catch (IOException e) {
            System.err.println(e); 
        }
    }
        
    try{
        f7 = new FastFractal("DoubleDip", 3, 1, 1, dimension); // as suggested in "fastfractal_doubledip.cpp"
    }
    catch (Exception e){
        System.out.println("f7 is not generated properly");
    }
       
    // build the model
    buildModel();

    // build the display
    if (BATCH == false)
        buildDisplay();

    // build the schedule
    buildSchedule();

    if (BATCH == false)
    {
        // Display the plot
        aPlot.display();
      
        // Display the graph
        graph.display();
    }
    
  }

  /**
   * setup() prepares the model for another run. Called whenver the setup button
   * is clicked. Setup should set any objects that are created over the course
   * of the run to null, and dispose of any DisplaySurfaces or graphs. While
   * not strictly necessary this should some prevent memory leaks and calling
   * System.gc() helps too. The initial parameters should be set to whatever
   * defaults the user wants to see initially.
   */
  public void setup() {
       
    gBestValue = 1.7976931348623157E308;
    prevGBestValue = 1.7976931348623157E308;
    fitnessValue = 1.7976931348623157E308;
    randomPresentFitValue = 1.7976931348623157E308;
    deltaGBestValue = 0.0;
    
    numEvals = 0; // counting starts from 0

    // Initialize all the variables    
    schedule = null;
            
    if (aPlot != null)
      aPlot.dispose();
    aPlot = null;
  
    if (graph != null) {
      graph.dispose();
      graph = null;
    } 

    // Create the plot for the decision space
    aPlot = new Plot("Fitness-Decision space plot");
    //for (int i=0; i < numParticles; i++)
    //    aPlot.addLegend(i, "current", Color.BLACK, OpenGraph.CIRCLE);
    
    // new sequence graph
    graph = new OpenSequenceGraph("gBestValue Graph", this);
    this.registerMediaProducer("gBest Graph", graph);
     
    // create a schedule with an interval of one.
    schedule = new Schedule(); 
    
    System.gc();
     
  }

  /**
   * A required method, returns the schedule associated with this model
   */
  public Schedule getSchedule() {
    return schedule;
  }

  /**
   * a required method - displayed on the Controller toolbar.
   */
  public String getName() {
    return "CCPSO2";
  }


  /**
   * The typical way to code a simulation is to divide up the creation of the
   * simulation into three methods - buildModel(), buildDisplay(),
   * buildSchedule(). This division is not strictly necessary, but it does
   * make the creation conceptually clearer.
   *
   * The buildModel() method is responsible for creating those parts of the
   * simulation that represent what is being modeled. Consequently, the agents
   * and their environment are typically created here together with any
   * optional data collection objects. Of course, this method may call other
   * methods to help build the model.
   */
  public void buildModel() {
    
    System.out.println("Build Model");     
    System.out.println("numParticles: "+numParticles);
    System.out.println("dimension: "+dimension);
/*    System.out.print("swarmDimsArray: {");
    for(int i=0; i<swarmDimsArraySize; ++i)
        System.out.print(swarmDimsArray[i]+",");
    System.out.println("}");
*/    
    System.out.println("swarmDims: "+swarmDim);
    System.out.println("Method: "+method);
    System.out.println("Function: "+function);
    System.out.println("leftRange and rightRange: ["+leftRange+" "+rightRange+"]");
       
    // We start off by adding new swarm into the swarmList
    for (int i = 0; i < numSwarms; i++) 
    {   
        PSOSwarm swarm = new PSOSwarm(this, i, swarmDim);
        swarmList.add(swarm);       
    }
    
    // update pop and v.
    for (int m = 0; m < numSwarms; m++) 
    {
        PSOSwarm swarm = (PSOSwarm) swarmList.get(m);      
        ArrayList agentList1 = swarm.getAgentList();
        
        for(int i=0; i < agentList1.size(); i++)
        {
            PSOAgent agent = (PSOAgent) agentList1.get(i);
            // first need to save the agent back to a row of pop array
            // then we need to reload it again, before doing the shuffling
            updatePopRow(agent.getPresent(),pop,m,i);
            updatePopPBestRow(agent.getPBest(),popPBest,m,i);
            updateVRow(agent.getVelocity(),v,m,i);
        }  
    }
    
    // assign original index to the index list
    for(int k=0; k<dimension; k++)
    {
         DimIndex dimIndex = new DimIndex(k, 0);
         indexList.add(dimIndex);
    }   
    
    if (BATCH ==  true)
    {
        // create a new DataRecorder and write the data to ./sugar_data.txt
        //recorder = new DataRecorder("./"+dimension+"d-"+"pop"+numParticles+".rst", this);     
        recorder = new DataRecorder("./"+"pop"+numParticles+".rst", this);     
         
        // Adds a data source that records gBestValue.
        recorder.addNumericDataSource("gBestValue - Data.f_bias[functionID]", new gBestValueSource());
        //recorder.addNumericDataSource("numEvals", new numEvalsSource());
    }
  }

  /**
   * data source for recording gBestValue
   */
  class gBestValueSource implements NumericDataSource {
    public double execute() {
      return gBestValue - Data.f_bias[functionID];      
    }
  }


  /**
   * data source for recording numEvals
   */
  class numEvalsSource implements NumericDataSource {
    public double execute() {
      return numEvals;      
    }
  }
 
 
 
  /**
   * buildDisplay() builds those parts of the simulation that have to do with
   * displaying the simulation to a user.
   */
  protected void buildDisplay() {

    // Create a display to display the agentGrid on the screen.
    // This will display any Drawable contained within the Object2DGrid
    // In a non-BATCH simulation the agents in a simulation will typically
    // implement the Drawable interface.

    graph.setXRange(0, 200);
    graph.setYRange(0, 100);
    graph.setAxisTitles("Iteration", "gBest Value");
    
    // have the graph create the sequence for us from the getNumTriggered method.
    
    graph.addSequence("gBestValue", new Sequence() {
        public double getSValue() {
         return gBestValue - Data.f_bias[functionID];
    }
    });       
  }



  /**
   * buildSchedule builds the schedule that changes the simulations state.
   * Under this scheme, a simulation is a state machine where all transitions
   * between states are the result of actions initiated by a schedule.
   */
  public void buildSchedule() {
     // For each iteration (tick) of the simulation, call the step() method
     // of this PSOModel object to update the update the position,
     // pBest, gBest of the particle swarm
     
     schedule.scheduleActionBeginning(0, this, "step");
     if (BATCH == true)
     {
        schedule.scheduleActionAtEnd(recorder, "record");
        schedule.scheduleActionAtEnd(recorder, "writeToFile");
     }
     schedule.scheduleActionAtEnd(this, "writeStat");
  }

 
  public void writeStat() {
    double error = gBestValue - Data.f_bias[functionID];
    System.out.println("error: "+error);
    
    // reverse the gBest to the original order too
/*    double[] gBestCopy = new double[dimension];
    for(int k=0; k<dimension; k++)
    {
        int temp = ((DimIndex)indexList.get(k)).getOrgIndex();
        gBestCopy[temp] = gBest[k];
    }
    for(int k=0; k<dimension; k++)
        gBest[k] = gBestCopy[k]; 

    for(int k=0; k < 5; k++)
        System.out.print(gBest[k]+" ");
*/       
    if (OUTGBEST == true){
        try
        {
            out.newLine();
            summary.newLine();
        }
        catch (IOException e) {
            System.err.println(e); 
        }
        finally 
        {   // always close the file
            if (out != null) try {
                out.close();
            } catch (IOException ioe2) {
                // just ignore it
            }
            if (summary != null) try {
                summary.close();
            } catch (IOException ioe3) {
                // just ignore it
            }
        } // end try/catch/finally
    }
  }
 
  /**
   * This step() method update all swarms at each step.
   */
  public void step() {   
    
    // If hit the maximum number of evaluations then stop
    if (numEvals > maxNumEvals)
        this.stop();
                      
    if (BATCH == false)
    {     
        // Clear the plot first 
        for (int i=0; i < numParticles; i++)
            aPlot.clear(i);
    }
    // if no improvement from a cyle, then randomly select a swarmDim size
    if (deltaGBestValue <= 0 && ADAPTIVEGROUPSIZE == true)
    {
        int randSelect, sDim;
        randSelect = (int)(Math.floor(Math.random() * swarmDimsArraySize));  //select a random swarmDim
        sDim = swarmDimsArray[randSelect];
    
        swarmDim = sDim;     
        numSwarms = dimension/swarmDim;   
        //System.out.println("no improvement!"); 
    }

    //System.out.println(getTicks()+"\t"+swarmDim);
    //System.out.println("prevGBestValue: "+prevGBestValue);
    //System.out.println("gBestValue: "+gBestValue);
    
    // if the swarm size is decreased manually ...
    if (RESIZE == true && getTicks()%resizeIters == 0)
    {    
        // decreasing to 1
        if (numSwarms >= 2)
            numSwarms = numSwarms/2;
        if (numSwarms == 1)
            swarmDim = dimension;
        else
            swarmDim = dimension/numSwarms;
                
        // from small to large
        /*numSwarms = numSwarms*2;
        if (numSwarms >= dimension)
            numSwarms = dimension;
        swarmDim = dimension/numSwarms;
        */
        
        System.out.println("numSwarms: "+numSwarms);              
    }
    
    swarmList.clear();
    // Create a list of swarms
    for (int i = 0; i < numSwarms; i++) 
    {   
        PSOSwarm swarm = new PSOSwarm(this, i, swarmDim);
        swarmList.add(swarm);       
    }   
    
    // Iterate through each swarm to update its particles from pop and v
    for (int m = 0; m < numSwarms; m++) 
    {
        PSOSwarm swarm = (PSOSwarm) swarmList.get(m);  
        
        double[][] subpop = new double[numParticles][swarmDim];
        double[][] subpopPBest = new double[numParticles][swarmDim];
        double[][] subV = new double[numParticles][swarmDim];
        
        // obtain subpop (from lB to lB+swarmDim)
        int lB = m*swarmDim;
        for (int i = 0; i < numParticles; i++)
            for (int k = 0; k < swarmDim; k++)
            {
                subpop[i][k] = pop[i][lB+k];
                subpopPBest[i][k] = popPBest[i][lB+k];
                subV[i][k] = v[i][lB+k];
            }
                      
        ArrayList agentList1 = new ArrayList();
        agentList1 = swarm.getAgentList();
                
        //System.out.println("swarm: "+m);
        for(int i=0; i < agentList1.size(); i++)
        {
            PSOAgent agent = (PSOAgent) agentList1.get(i);
            agent.setPresent(subpop[i]);
            agent.setPBest(subpopPBest[i]);
            agent.setVelocity(subV[i]);
        }
            
        // set gBest for each swarm
        double[] swarmGBest = new double[swarmDim];        
        for (int k = 0; k < swarmDim; k++)
            swarmGBest[k] = gBest[lB+k];
        swarm.setGBest(swarmGBest);
        swarm.setGBestValue(gBestValue);
    }   
     
    // set prevGBest first before a cycle
    prevGBestValue = gBestValue;
    setPrevGBest(gBest);
      
    // cooperative coevolving, syncronized updates, similar to CCGA2 (Potter, De Jong, 1994)   
    ccpso_sync();
        
    // get the improvement in gBestValue right after the cycle
    deltaGBestValue = prevGBestValue - gBestValue;              
    //System.out.println("deltaGBestValue: "+deltaGBestValue);               
    //System.out.println("gBestValue: "+gBestValue);   
                        
    // if applying delta based grouping
    if (GROUPBYDELTA == true)
    {
        //if deltaGBestValue is not zero, then apply delta-based grouping (sort the list from low to high)
        //if (deltaGBestValue != 0 && getTicks()<resizeIters)
        //if (deltaGBestValue != 0)
            groupByDelta(indexList,deltaGBest,pop,popPBest,v,prevGBest,gBest);
        //else
        //    randomGrouping(indexList,pop,v,gBest); 
    }
    
    // runs only random grouping, but NOT rank based grouping    
    //if (RGROUPING == true && deltaGBestValue <= 0)
    if (RGROUPING == true)
       randomGrouping(indexList,pop,popPBest,v,gBest); 
   
    if (BATCH == false)
    {
        aPlot.fillPlot();
        aPlot.updateGraph();  

        // draw the fitness plot
        graph.step();
    }      
  }
 

 
  /********************************************************/
  /********************************************************/ 
  // apply ranks (based on delta) to grouping to all dimensions of pop and v
  public void groupByDelta(ArrayList indexList, double[] deltaGBest, double[][] pop, double[][] popPBest, double[][] v, double[] prevGBest, double[] gBest)
  {
    //reverse back to the original order for pop and v
    double[][] popCopy = new double[numParticles][dimension];
    double[][] popPBestCopy = new double[numParticles][dimension];
    double[][] vCopy = new double[numParticles][dimension];

    for (int i=0; i < numParticles; i++)
        for (int k=0; k < dimension; k++)
        {
            int temp = ((DimIndex)indexList.get(k)).getOrgIndex();
            popCopy[i][temp] = pop[i][k];
            popPBestCopy[i][temp] = popPBest[i][k];
            vCopy[i][temp] = v[i][k];
        }
        
    //update pop and v in their original order
    for (int i=0; i < numParticles; i++)
        for (int k=0; k < dimension; k++)
        {
            pop[i][k] = popCopy[i][k];
            popPBest[i][k] = popPBestCopy[i][k];
            v[i][k] = vCopy[i][k];
        }

    // reverse the gBest to the original order too
    double[] gBestCopy = new double[dimension];
    double[] prevGBestCopy = new double[dimension];
    for(int k=0; k<dimension; k++)
    {
        int temp = ((DimIndex)indexList.get(k)).getOrgIndex();
        gBestCopy[temp] = gBest[k];
        prevGBestCopy[temp] = prevGBest[k];
    }
    for(int k=0; k<dimension; k++)
    {
        gBest[k] = gBestCopy[k]; 
        prevGBest[k] = prevGBestCopy[k];       
    }    

    // once finishing reversing everything back to the original order, then  
    // calculate the difference in each dimension between gBest and prevGBest
    for(int k=0; k<dimension; k++)
        deltaGBest[k] = Math.abs(gBest[k] - prevGBest[k]);
        //((DimIndex)indexList.get(k)).setDelta(deltaGBest[k]);
        
    indexList.clear();
    // assign original index to the index list
    for(int k=0; k<dimension; k++)
    {
         DimIndex dimIndex = new DimIndex(k, deltaGBest[k]);
         indexList.add(dimIndex);
    }   

    // sort indexList according to delata values
    indexList = sortAList(indexList);
/*    System.out.println("after sort: ");
    for(int k=0; k<dimension; k++)
        System.out.print(((DimIndex)indexList.get(k)).getOrgIndex()+": ");   
    for(int k=0; k<dimension; k++)
        System.out.print(((DimIndex)indexList.get(k)).getDelta()+": ");   
*/
      
    // orderng the pop according to delta values in indexList
    for (int i=0; i < numParticles; i++)
      for (int k=0; k < dimension; k++)
      {            
          int temp = ((DimIndex)indexList.get(k)).getOrgIndex();
          popCopy[i][k] = pop[i][temp]; //pop needs to be always in the original order
          popPBestCopy[i][k] = popPBest[i][temp];
          vCopy[i][k] = v[i][temp];
      }

    for (int i=0; i < numParticles; i++)
      for (int k=0; k < dimension; k++)
      {
            pop[i][k] = popCopy[i][k];
            popPBest[i][k] = popPBestCopy[i][k];
            v[i][k] = vCopy[i][k];
      }

    // re-arrange the gBest dimensions for delta-based grouping    
    for(int k=0; k<dimension; k++)
    {
      int temp = ((DimIndex)indexList.get(k)).getOrgIndex();
      gBestCopy[k] = gBest[temp];
    }
    for(int k=0; k<dimension; k++)
      gBest[k] = gBestCopy[k]; 
 }

  
  // apply random grouping to all dimensions of pop and v
  public void randomGrouping(ArrayList indexList, double[][] pop, double[][] popPBest, double[][] v, double[] gBest)
  {
    //reverse back to the original order for pop and v
    double[][] popCopy = new double[numParticles][dimension];
    double[][] popPBestCopy = new double[numParticles][dimension];
    double[][] vCopy = new double[numParticles][dimension];

    for (int i=0; i < numParticles; i++)
        for (int k=0; k < dimension; k++)
        {
            int temp = ((DimIndex)indexList.get(k)).getOrgIndex();
            popCopy[i][temp] = pop[i][k];
            popPBestCopy[i][temp] = popPBest[i][k];
            vCopy[i][temp] = v[i][k];
        }
    //update pop and v in their original order
    for (int i=0; i < numParticles; i++)
        for (int k=0; k < dimension; k++)
        {
            pop[i][k] = popCopy[i][k];
            popPBest[i][k] = popPBestCopy[i][k];
            v[i][k] = vCopy[i][k];
        }

    // reverse the gBest to the original order too
    double[] gBestCopy = new double[dimension];
    for(int k=0; k<dimension; k++)
    {
        int temp = ((DimIndex)indexList.get(k)).getOrgIndex();
        gBestCopy[temp] = gBest[k];
    }
    for(int k=0; k<dimension; k++)
        gBest[k] = gBestCopy[k];       
        
    // once finishing reversing everything back to the original order then
    // shuffle the indexList from the original order of pop and v  
    
    indexList.clear();
    // assign original index to the index list
    for(int k=0; k<dimension; k++)
    {
         DimIndex dimIndex = new DimIndex(k, 0);
         indexList.add(dimIndex);
    } 
           
    for (int k = 0; k < dimension; k++) 
    {
        int r = (int) (Math.random() * (k+1));     // int between 0 and i
        DimIndex swap = (DimIndex)indexList.get(r);
        DimIndex temp = (DimIndex)indexList.get(k);
        indexList.set(r, temp);
        indexList.set(k, swap);
    }

/*    for (int k = 0; k < dimension; k++) 
    {
        int temp = ((DimIndex)indexList.get(k)).getOrgIndex();
        System.out.println("k = "+k+": "+temp);
    }
*/    
    // random permutation of the pop
    for (int i=0; i < numParticles; i++)
        for (int k=0; k < dimension; k++)
        {
            int temp = ((DimIndex)indexList.get(k)).getOrgIndex();
            popCopy[i][k] = pop[i][temp];
            popPBestCopy[i][k] = popPBest[i][temp];
            vCopy[i][k] = v[i][temp];
        }

    for (int i=0; i < numParticles; i++)
        for (int k=0; k < dimension; k++)
        {
            pop[i][k] = popCopy[i][k];
            popPBest[i][k] = popPBestCopy[i][k];
            v[i][k] = vCopy[i][k];
        }
    
    // Shuffle the gBest dimensions for random grouping
    for(int k=0; k<dimension; k++)
    {
        int temp = ((DimIndex)indexList.get(k)).getOrgIndex();
        gBestCopy[k] = gBest[temp];
    }
    for(int k=0; k<dimension; k++)
        gBest[k] = gBestCopy[k];           
 }
  
 
  
  /********************************************************/
  /********************************************************/
   
  // this version use both gBest and randomSelect from the remaining swarms
  // equivalent to CCGA2 (Potter, De Jong, 1994)
  public void ccpso_Sk2()
  { 
               
    // Iterate through the list of swarms and agents and do the following
    for (int m = 0; m < numSwarms; m++) 
    {
        PSOSwarm swarm = (PSOSwarm) swarmList.get(m);      
        ArrayList agentList1 = swarm.getAgentList();
        //System.out.println("swarm: "+m); 
                                
        for(int i=0; i < agentList1.size(); i++)
        {
            PSOAgent agent = (PSOAgent) agentList1.get(i);
            setPresent(agent.getPresent(),m);
                                    
            for (int n = 0; n < numSwarms; n++)
            {
                PSOSwarm swarm2 = (PSOSwarm) swarmList.get(n);
                if (m!=n)
                {
                    if (getTickCount() == 1)
                        setPresent(swarm2.getRandomPresent(),n);
                    else
                        setPresent(swarm2.getGBest(),n); 
                }                                  
            }
            
            // get the random super individual
            setRandomPresent(agent.getPresent(), m);
            for (int n = 0; n < numSwarms; n++)
            {
                PSOSwarm swarm2 = (PSOSwarm) swarmList.get(n);
                if (m!=n)
                   setRandomPresent(swarm2.getRandomPresent(),n);                 
            }
            
            // first reverse the index back to original before evaluating it
            double[] presentOrgIndex = new double[dimension];
            double[] randomPresentOrgIndex = new double[dimension];
            
            for(int k=0; k<dimension; k++)
            {
                int temp = ((DimIndex)indexList.get(k)).getOrgIndex();
                presentOrgIndex[k] = present[temp];
                randomPresentOrgIndex[k] = randomPresent[temp];                
            }
            
            // calculate and set the fitnessValue for the agent
            fitnessValue = calculateFitness(presentOrgIndex);
            randomPresentFitValue = calculateFitness(randomPresentOrgIndex);
           
            if (fitnessValue < randomPresentFitValue)
                agent.setFitnessValue(fitnessValue);    
            else
                agent.setFitnessValue(randomPresentFitValue);
                        
            numEvals++;           
            
            // update the agent's pBest and pBestValue
            agent.step();
            
            // update the swarm's gBest 
            double pBestValue = agent.getPBestValue();
            double swarmGBestValue = swarm.getGBestValue();   
            //System.out.println("fitnessValue: "+fitnessValue);         
            if (pBestValue < swarmGBestValue)
            {
                swarm.setGBestValue(pBestValue);
                swarm.setGBest(agent.getPBest());
                //System.out.println("update swarm's gBest");
            }
            
            // set gBest for each particle in each swarm
            agent.setGBestValue(swarm.getGBestValue());
            agent.setGBest(swarm.getGBest());
  
            if (fitnessValue < gBestValue)
            {    
                // set the gBest
                gBestValue = fitnessValue; 
                setGBest(present);
            }    
            
            // output the gBestValue at a certain evaluation number
            if ((OUTGBEST == true) && (numEvals%interval == 0 || numEvals == 1))
            {
                // output the gBestValue
                try
                { 
                    out.write(Double.toString(this.gBestValue - Data.f_bias[functionID])+",");   
                }
                catch (IOException e) {
                    System.err.println(e); 
                }
            }
            
            int sumAtEvals = dimension * 5000; 
            // output the gBestValue at the selected eval numbers.         
            if (OUTGBEST == true && (numEvals == sumAtEvals || numEvals == sumAtEvals*10 || numEvals == sumAtEvals*100))
            {
                System.out.println("numEvals: "+numEvals);
                // output the gBestValue at the selected eval numbers.
                try
                { 
                    summary.write(Double.toString(this.gBestValue - Data.f_bias[functionID])+",");   
                }
                catch (IOException e) {
                    System.err.println(e); 
                }           
            }   
            
            if (BATCH == false && m == 0)
            {
                aPlot.plotPoint(present[0], present[1], i);
            }
            
            // update each particle in each swarm 
            agent.update();
            
            // first need to save the agent back to a row of pop array
            // then we need to reload it again, before doing the shuffling
            //if (RGROUPING == true && deltaGBestValue == 0.0)
            {
                updatePopRow(agent.getPresent(),pop,m,i); 
                updateVRow(agent.getVelocity(),v,m,i);
            }           
        }//agentList1 loop                    
    }// finish one cycle
     
  }



/****************************************************************************/
  // this version only update each particle's gBest after all calculations done
  // both present and randomPresent will be calculated
/****************************************************************************/
    public void ccpso_sync()
    {
        // iterate through the list of swarms and list of particles for each swarm
        // calculate the fitness and update the pBest for each particle
        for (int m = 0; m < numSwarms; m++)
        {
            PSOSwarm swarm = (PSOSwarm)swarmList.get(m);
            ArrayList agentList1 = swarm.getAgentList();
            //System.out.println("swarm: "+m);
            for (int i = 0; i < agentList1.size(); i++)
            {
                PSOAgent agent = (PSOAgent)agentList1.get(i);

                // get the present plus all other best particles from all swarms
                setPresent(agent.getPresent(), m);
                for (int n = 0; n < numSwarms; n++)
                {
                    PSOSwarm swarm2 = (PSOSwarm)swarmList.get(n);
                    if (m != n)
                    {
                        if (getTickCount() == 1)
                            setPresent(swarm2.getRandomPresent(), n);
                        else
                            setPresent(swarm2.getGBest(), n);
                    }
                }

                // get the random super individual
/*                setRandomPresent(agent.getPresent(), m);
                for (int n = 0; n < numSwarms; n++)
                {
                    PSOSwarm swarm2 = (PSOSwarm)swarmList.get(n);
                    if (m != n)
                        setRandomPresent(swarm2.getRandomPresent(), n);
                }
*/
                //System.out.println("i: "+i);
                //for(int k=0; k < dimension; k++)
                //    System.out.print("present["+k+"]"+present[k]);
                //System.out.println();

                // first reverse the index back to original before evaluating it
                double[] presentOrgIndex = new double[dimension];
                //double[] randomPresentOrgIndex = new double[dimension];
                
                for (int k = 0; k < dimension; k++)
                {
                    int temp = ((DimIndex)indexList.get(k)).getOrgIndex();
                    presentOrgIndex[temp] = present[k];
                    //randomPresentOrgIndex[temp] = randomPresent[k];
                    //System.out.println("kup"+k+" "+temp);
                }

                // calculate and set the fitnessValue for the agent
                fitnessValue = calculateFitness(presentOrgIndex);
                //randomPresentFitValue = calculateFitness(randomPresentOrgIndex);

                //if (fitnessValue < randomPresentFitValue)
                    agent.setFitnessValue(fitnessValue);
                //else
                //    agent.setFitnessValue(randomPresentFitValue);

                // set pBest superindividual
                setPresent(agent.getPBest(), m);
                for (int n = 0; n < numSwarms; n++)
                {
                    PSOSwarm swarm2 = (PSOSwarm)swarmList.get(n);
                    if (m != n)
                    {
                        if (getTickCount() == 1)
                            setPresent(swarm2.getRandomPresent(), n);
                        else
                            setPresent(swarm2.getGBest(), n);
                    }
                }

                // first reverse the index back to original before evaluating it
                double[] pBestOrgIndex = new double[dimension];           
                for (int k = 0; k < dimension; k++)
                {
                    int temp = ((DimIndex)indexList.get(k)).getOrgIndex();
                    pBestOrgIndex[temp] = present[k];
                }

                // calculate and set the fitnessValue for the agent
                double pBestValue = calculateFitness(pBestOrgIndex);
                agent.setPBestValue(pBestValue);
                
                numEvals++;
                numEvals++;
                
                // output the gBestValue at a certain evaluation number
                if ((OUTGBEST == true) && (numEvals % interval == 0 || numEvals == 1))
                {
                    // output the gBestValue
                    try
                    {
                        out.write(Double.toString(this.gBestValue - Data.f_bias[functionID])+",");   
                    }
                    catch (IOException e)
                    {
                        System.err.println(e);
                    }
                }
                int sumAtEvals = dimension * 5000; 
                // output the gBestValue at the selected eval numbers.         
                if (OUTGBEST == true && (numEvals == sumAtEvals || numEvals == sumAtEvals*10 || numEvals == sumAtEvals*100))
                {
//                  System.out.println("numEvals: "+numEvals);
                    try
                    {
                       summary.write(Double.toString(this.gBestValue - Data.f_bias[functionID])+",");   
                    }
                    catch (IOException e) {
                        System.err.println(e); 
                    }           
                }   

                // update the agent's pBest and pBestValue if present is better
                agent.step();
                
                // update the swarm's gBest 
                pBestValue = agent.getPBestValue();
                double swarmGBestValue = swarm.getGBestValue();
                //System.out.println("pBestValue: "+pBestValue);         
                if (pBestValue < swarmGBestValue)
                {
                    swarm.setGBestValue(pBestValue);
                    swarm.setGBest(agent.getPBest());
                    //System.out.println("update swarm's gBest");
                }

                if (BATCH == false && m == 0)
                    aPlot.plotPoint(present[0], present[1], i);
            }//agentList1
            
            // set gBest super individual
            double swarmGBestValue = swarm.getGBestValue();            
            if (swarmGBestValue < gBestValue)
            {
                gBestValue = swarmGBestValue; 
                for (int n = 0; n < numSwarms; n++)
                {
                    PSOSwarm swarm2 = (PSOSwarm)swarmList.get(n);
                    setPresent(swarm2.getGBest(), n);
                }
                setGBest(present);
            }
        }//numSwarms

        //set gBest for each particle in each swarm and update them
        for (int m = 0; m < numSwarms; m++)
        {
            PSOSwarm swarm = (PSOSwarm)swarmList.get(m);
            ArrayList agentList1 = swarm.getAgentList();
            
            // set nBest for all particles in the swarm (for CCPSO_Ring)
            //if (swarm.getMethod().equals("CCPSO_Ring"))
                swarm.setAllNBest(); 
            
            for (int i = 0; i < agentList1.size(); i++)
            {
                PSOAgent agent = (PSOAgent)agentList1.get(i);

                // set gBest for each particle in each swarm
                agent.setGBestValue(swarm.getGBestValue());
                agent.setGBest(swarm.getGBest());

                agent.update();
                //update the pop and v for the agent
                updatePopRow(agent.getPresent(), pop, m, i);
                updatePopPBestRow(agent.getPBest(), popPBest, m, i);
                updateVRow(agent.getVelocity(), v, m, i);
            }
        }

  }

  public void updatePopRow(double[] p, double[][] pop, int j, int i) {
    
    int lB = j*swarmDim;
    for (int k = 0; k < swarmDim; k++)
    {
        pop[i][lB+k] = p[k];
        //System.out.println("**pop["+i+"]["+(lB+k)+"]: "+pop[i][lB+k]);
    }
  }
  
   public void updatePopPBestRow(double[] p, double[][] popPBest, int j, int i) {
    
    int lB = j*swarmDim;
    for (int k = 0; k < swarmDim; k++)
    {
        popPBest[i][lB+k] = p[k];
        //System.out.println("**popPBest["+i+"]["+(lB+k)+"]: "+popPBest[i][lB+k]);
    }
  }
  
   public void updateVRow(double[] vel, double[][] v, int j, int i) {
    
    int lB = j*swarmDim;
    for (int k = 0; k < swarmDim; k++)
    {
        v[i][lB+k] = vel[k];
        //System.out.println("**v["+i+"]["+(lB+k)+"]: "+v[i][lB+k]);
    }
  }
  
  
  public void setFunctionParams()
  {
    if (getFunction().equals("Sphere") || getFunction().equals("ShiftedSphere") 
        || getFunction().equals("SchwefelProblem") || getFunction().equals("ShiftedRosenbrock") || getFunction().equals("ShiftedRotatedRosenbrock") )
    {
        leftRange = -100.0;
        rightRange = 100.0;
        velocityMax = 100.0;
    }
    else if (getFunction().equals("ShiftedRastrigin") || getFunction().equals("Rastrigin") || getFunction().equals("ShiftedRotatedRastrigin"))
    {
        leftRange = -5.0;
        rightRange = 5.0;
        velocityMax = 5.0;
    } 
    else if (getFunction().equals("ShiftedAckley") || getFunction().equals("ShiftedRotatedAckley") )
    {
        leftRange = -32.0;
        rightRange = 32.0;
        velocityMax = 32.0;
    }
    if (getFunction().equals("FastFractal"))
    {
        leftRange = -1.0;
        rightRange = 1.0;
        velocityMax = 1.0;
    } 
    else if (getFunction().equals("ShiftedGriewank") || getFunction().equals("ShiftedRotatedGriewank") )
    {
        leftRange = -600.0;
        rightRange = 600.0;
        velocityMax = 600.0;
    }
    else if(getFunction().equals("Rosenbrock")|| getFunction().equals("RRosenbrock"))
    {
        leftRange = -30.0;
        rightRange = 30.0;
        velocityMax = 30.0;
    }
  }
    
   
  protected double calculateFitness(double[] present) {

   // Calculate fitness value
   double fitValue = 1.7976931348623157E308;  
   
   if (getFunction().equals("Sphere")) 
       fitValue = sphere(present);    
   else if (getFunction().equals("Rastrigin")) 
       fitValue = rastrigin(present);   
   else if (getFunction().equals("RRastrigin")) 
       fitValue = rastrigin(present);     
   else if(getFunction().equals("Rosenbrock"))
       fitValue = rosenbrock(present); 
   else if(getFunction().equals("ShiftedSphere"))
       fitValue = shiftedSphere(dimension, present);
   else if(getFunction().equals("SchwefelProblem"))
       fitValue = schwefelProblem(dimension, present);
   else if(getFunction().equals("ShiftedRosenbrock"))
       fitValue = shiftedRosenbrock(dimension, present);
   else if(getFunction().equals("ShiftedRotatedRosenbrock"))
       fitValue = shiftedRotatedRosenbrock(dimension, present);
   else if(getFunction().equals("ShiftedRastrigin"))
       fitValue = shiftedRastrigin(dimension, present);
   else if(getFunction().equals("ShiftedRotatedRastrigin"))
       fitValue = shiftedRotatedRastrigin(dimension, present);
   else if(getFunction().equals("ShiftedGriewank"))
       fitValue = shiftedGriewank(dimension, present);
   else if(getFunction().equals("ShiftedRotatedGriewank"))
       fitValue = shiftedRotatedGriewank(dimension, present);
   else if(getFunction().equals("ShiftedAckley"))
       fitValue = shiftedAckley(dimension, present);
   else if(getFunction().equals("ShiftedRotatedAckley"))
       fitValue = shiftedRotatedAckley(dimension, present);
   else if(getFunction().equals("FastFractal"))
       fitValue = f7.evaluate(present);
   return fitValue;
 }
   
  
  public int getNumParticles() {
    return numParticles;
  }

  public void setNumParticles(int num) {
    numParticles = num;
  }


  public int getNumSwarms() {
    return numSwarms;
  }

  public void setNumSwarms(int num) {
    numSwarms = num;
  }

  public double getLeftRange() {
    return leftRange;
  }

  public void setLeftRange(double lr) {
    leftRange = lr;
  }
 
  public double getRightRange() {
    return rightRange;
  }

  public void setRightRange(double rr) {
    rightRange = rr;
  }

  public double getVelocityMax() {
    return velocityMax;
  }

  public void setVelocityMax(double v) {
    velocityMax = v;
  }
  
  public int getMaxIterations() {
       return maxIterations;
   }

  public void setMaxIterations(int gen)  {
       maxIterations = gen;
  }

  public int getMaxNumEvals() {
       return maxNumEvals;
   }

  public void setMaxNumEvals(int mne)  {
       maxNumEvals = mne;
  }

  public int getDimension() {
      return dimension;
  }

  public void setDimension(int dim) {
      dimension = dim;
  }
  
  public double[] getGBest() {
    return gBest;
  }

  public void setGBest(double[] gb) {
    for (int j=0; j < dimension; j++)
        gBest[j] = gb[j];
  }

  public void setPrevGBest(double[] pgb) {
    for (int j=0; j < dimension; j++)
        prevGBest[j] = pgb[j];
  }
 
  public String getFunction() {
       return function;
   }

   public void setFunction(String f) {
       function = f;
   }
 
   public int getRun() {
       return run;
   }

   public void setRun(int r) {
       run = r;
   }
  
  public boolean getBatch() {
    return BATCH;
  }

  public void setBatch(boolean b) {
     BATCH = b;
  }

  public boolean getRGROUPING() {
    return RGROUPING;
  }

  public void setRGROUPING(boolean s) {
     RGROUPING = s;
  }

  public boolean getRESIZE() {
    return RESIZE;
  }

  public void setRESIZE(boolean rs) {
     RESIZE = rs;
  }
  
  public boolean getOutGBest() {
    return OUTGBEST;
  }

  public void setOutGBest(boolean out) {
     OUTGBEST = out;
  }

  public boolean getRotationFlag() {
    return ROTATIONFLAG;
  }

  public void setRotationFlag(boolean rf) {
     ROTATIONFLAG = rf;
  }

  public String getMethod() {
    return method;
  }
  
  public void setMethod(String m) {
     method = m;
  }
 

  public boolean getADAPTIVEGROUPSIZE() {
    return ADAPTIVEGROUPSIZE;
  }
  
  public void setADAPTIVEGROUPSIZE(boolean gz) {
     ADAPTIVEGROUPSIZE = gz;
  }
 
 
  public double getRandomUniform() {
    return Random.uniform.nextDoubleFromTo(0, 1);
  }

  public double getGaussian() {
    return Random.normal.nextDouble();
  } 

  public double getCauchy() {
    return Distributions.nextCauchy(generator);
    
/*    double u, v, x;

    do { 
        u = 2*Random.uniform.nextDoubleFromTo(0, 1)-1; 
        v = 2*Random.uniform.nextDoubleFromTo(0, 1)-1; 
    } while (u*u+v*v>1.0 || (u==0.0&&v==0.0));
    if (u!=0) 
        return(v/u); 
    else 
        return(0.0);
*/    
  } 
 
  public double getRandomNormal() {
    return Random.normal.nextDouble(0,1.0);
  }

  public int getRandomUniformInt(int a, int b) {
    return Random.uniform.nextIntFromTo(a, b);
  }
  
  public double[][] getRotationMatrix() {
    return rotationmatrix;
  }
 
  public double getTicks() {
    return this.getTickCount();
  } 
 
  public void setTicks(int ts) {
    ticks = ts;
  } 
  
  public boolean getGROUPBYDELTA() {
    return GROUPBYDELTA;
  } 
 
  public void setGROUPBYDELTA(boolean r) {
    GROUPBYDELTA = r;
  } 
  
  public double getResizeIters() {
    return resizeIters;
  } 
 
  public void setResizeIters(int ri) {
    resizeIters = ri;
  } 
  
  
  
  public void setPresent(double[] p, int m) {
  
    for (int j=0; j < swarmDim; j++)
    {
       present[m*swarmDim+j]= p[j];
       // System.out.println("present["+m*swarmDim+"]"+present[m*swarmDim+j]);       
    }
  }
 
  public void setRandomPresent(double[] p, int m) {
  
    for (int j=0; j < swarmDim; j++)
    {
       randomPresent[m*swarmDim+j]= p[j];
       // System.out.println("randomPresent["+m*swarmDim+"]"+randomPresent[m*swarmDim+j]);       
    }
  }
 
 
  public void setPresentWeighted(double[] p, int m, double wl, double wu) {
  
    double weight = (wu - wl) * getRandomUniform() + wl;
    for (int j=0; j < swarmDim; j++)
    {
       present[m*swarmDim+j]= p[j]*weight;
       // System.out.println("present["+m*swarmDim+"]"+present[m*swarmDim+j]);       
    }
  }
 
 
   public void setRandomPresentWeighted(double[] p, int m, double wl, double wu) {
  
    double weight = (wu - wl) * getRandomUniform() + wl;
    for (int j=0; j < swarmDim; j++)
    {
       randomPresent[m*swarmDim+j]= p[j]*weight;
       // System.out.println("present["+m*swarmDim+"]"+present[m*swarmDim+j]);       
    }
  }
 
 
   // sort aList according to some value (from low to high).
   private ArrayList sortAList(ArrayList aList)
   {
        double[] v = new double[dimension];
        ArrayList sortedList = new ArrayList();
        sortedList.addAll(aList);         
        //System.out.println("rank list size "+sortedList.size());
        Iterator sortedIter = sortedList.iterator();    
    
        //sort particles in ascending order according to delta values
        try 
        {               
            int i,j;
            i = 0;
            while (i < (sortedList.size() - 1))       
            {
                j = i + 1;                
                while (j < sortedList.size())
                {
                    // according to delta values, in ascending order
                    if (((DimIndex)sortedList.get(i)).getDelta() > ((DimIndex)sortedList.get(j)).getDelta())
                    {
                        DimIndex temp = (DimIndex)sortedList.get(i);
                        sortedList.set(i, sortedList.get(j));
                        sortedList.set(j, temp);
                    }  
                    j++;
                }
                i++;
            }
        } 
        catch (Exception e) 
        {
            e.printStackTrace (System.err);
        }   
        
        return sortedList;
   }

 
 
 
/*******  Functions related to rotation matrix  *******/   
 
private double vinprod(int n,double x1[],double x2[])
{
  double p;
  p = 0;

  for(int i=0;i<n;i++) {
    p += x1[i]*x2[i];
  }
  return p;
}


private double vnorm(int n,double x1[])
{
   double result = Math.sqrt(vinprod(n,x1,x1));
   return result;
}


private void vcopy(int n,double x1[],double x2[])
{
   for (int i=0;i<n;i++) {
      x1[i] = x2[i];
   }
}


private void vorth(int n,double x1[],double x2[],double x3[],double eps)
{
  double v2n,vp;
  v2n = vnorm(n,x2);
  vp = vinprod(n,x1,x2);
 
  for (int i=0;i<n;i++) {
    x3[i] = x1[i];
  }

 if (v2n < eps) {
    
   System.out.println("ERROR\n");
  }
  for (int i=0;i<n;i++) {
    x3[i] -= x2[i]*vp/v2n/v2n;
  }
}

public double[][] generateRotationMatrix(int dim) {

  double[][] orth2 = new double[dim][dim];

  double dd[] = new double[dim];
  double dd2[] = new double[dim];

  //System.out.println("Generating rotation matrix... please be patient\n");
  for(int i = 0; i < dim; i++)
  {
     for(int k = 0; k < dim; k++)
         orth2[i][k] = getRandomNormal();
  
     double norm = vnorm(dim,orth2[i]);

     for(int k = 0; k < dim; k++)
         orth2[i][k] = (orth2[i][k])*(1.0/norm);
  
     vcopy(dim,dd,orth2[i]);

     for(int k=0;k<i;k++) {
       vorth(dim,dd,orth2[k],dd2,10e-17);
       vcopy(dim,dd,dd2);
     }

     norm = vnorm(dim,dd);
     for(int k = 0; k < dim; k++)
         dd[k] = (dd[k])*(1.0/norm);

     vcopy(dim,orth2[i],dd);
  }
  return orth2;
}

/************** end of functions related to rotation matrix *********/


 
 
 /****************** Test functions *********************/
 
 /**
   * Return the fitness value of this agent based on its current position
   * @return
   */
  /** Parabola **/
  /* -20 <= x_i <= 20; i = 1 */
  /* the minimum is 0.0 */
  private double parabola(double[] present) {
    double total = 0;
    for (int i=0; i < dimension; i++) {
      total += (present[i] * present[i]);
    }
    return total; //minimization
  }
  


 /**
   * Return the fitness value of this agent based on its current position
   * @return
   */
  /** Sphere **/
  /* -100 <= x_i <= 100;  */
  /* the minimum is 0.0 */
  private double sphere(double[] present) {
    double total = 0;
    for (int i=0; i < dimension; i++) {
      total += ((present[i]) * (present[i]));
    }
    return total; //minimization
  }
  
 /**
   * Return the fitness value of this agent based on its current position
   * @return
   */
  /** Himmelblau function **/
  /* -6.0 <= x1 and x2 <= 6.0  */
 private double himmelblau(double[] present) {
 
   double y = 0;
   y = 200 - Math.pow((Math.pow(present[0], 2) + present[1] - 11), 2) 
           - Math.pow((present[0] + Math.pow(present[1], 2) - 7), 2);
   
   return y;
 }
 
  /** Rastrigin **/
  /* -5.12 <= x_i <= 5.12; i = 1...,30 */
  /* the minimum is 0.0 */
  private double rastrigin(double[] present) {
   double total = 0;
   for (int j=0; j < dimension; j++) {
     total += (present[j]*present[j]) - 10*Math.cos(2*Math.PI*present[j]) + 10;
   }
   return total; // minimization
  }
 
 private double rrastrigin(double[] present) {
    /*  X=[-5.12,5.12] */
    double[] r = new double[dimension];
    for(int i = 0; i < dimension; i++)
    r[i] = 0.0;
    
    double[][] rotmat = getRotationMatrix();

    for(int i = 0; i < dimension; i++)
    {
       for(int j = 0; j < dimension; j++)
          r[i] += rotmat[i][j]*(present[j]);
    }

    double A = 10.0;
    double w = 2.0*Math.PI;
    double total = 0; 
             
    for(int i = 0; i < dimension; i++)
        total += r[i]*r[i] - A*Math.cos(w*r[i]) + 10;
    
    return (total);
 }
 
 
 private double griewank(double[] present) {
    /* n = 10, X=[-600,600] */
    double total1 = 0, total2= 1.0;
    for (int i=0; i < dimension; i++) 
    {
        total1 += present[i]*present[i]/4000.0;
        total2 *= Math.cos(present[i]/Math.sqrt(i+1.0));
    }
    
    return (total1-total2+1.0); //minimization
 }

 private double rgriewank(double[] present) {
    /* n = 10, X=[-600,600] */
    double[] r = new double[dimension];
    for(int i = 0; i < dimension; i++)
    r[i] = 0.0;
    
    double[][] rotmat = getRotationMatrix();

    for(int i = 0; i < dimension; i++)
    {
       for(int j = 0; j < dimension; j++)
          r[i] += rotmat[i][j]*(present[j]);
    }

    double total1 = 0, total2= 1.0;
    for (int i=0; i < dimension; i++) 
    {
        total1 += r[i]*r[i]/4000.0;
        total2 *= Math.cos(r[i]/Math.sqrt(i+1.0));
    }
    
    return (total1-total2+1.0); //minimization
 }


 private double ackley(double[] present) {
  /* X=[-32.768, 32.768] */
  double total1= 0;
  double total2= 0;
  double total= 0;

  for(int i = 0; i < dimension; i++)
  {
      total1 += present[i]*present[i];
      total2 += Math.cos(2.0*Math.PI*present[i]);          
  }   
  total = -20.0*Math.exp(-0.2*Math.sqrt((1.0/dimension)*total1))-Math.exp((1.0/dimension)*total2) +20.0 +Math.E;
  return total;

 }

 private double rackley(double[] present) {
    /* X=[-32.768, 32.768] */
    double[] r = new double[dimension];
    for(int i = 0; i < dimension; i++)
    r[i] = 0.0;
    
    double[][] rotmat = getRotationMatrix();

    for(int i = 0; i < dimension; i++)
    {
       for(int j = 0; j < dimension; j++)
          r[i] += rotmat[i][j]*(present[j]);
    }

    double total1= 0;
    double total2= 0;
    double total= 0;

    for(int i = 0; i < dimension; i++)
    {
      total1 += r[i]*r[i];
      total2 += Math.cos(2.0*Math.PI*r[i]);          
    }   
    total = -20.0*Math.exp(-0.2*Math.sqrt((1.0/dimension)*total1))-Math.exp((1.0/dimension)*total2) +20.0 +Math.E;
    return total;
 }

 private double schwefel(double[] present) {
    /* X=[-500,500] */   
    double total = 0;
    for(int i = 0; i < dimension; i++)
    {
       total += -present[i]*Math.sin(Math.sqrt(Math.abs(present[i])));
    }
    total += 418.9829*dimension + total;
    return total;
 }   

 private double rschwefel(double[] present) {
    /* X=[-500,500] */   
    double[] r = new double[dimension];
    for(int i = 0; i < dimension; i++)
        r[i] = 0.0;
    
    double[][] rotmat = getRotationMatrix();

    for(int i = 0; i < dimension; i++)
    {
       for(int j = 0; j < dimension; j++)
          r[i] += rotmat[i][j]*(present[j]);
    }

    double total = 0;
    for(int i = 0; i < dimension; i++)
    {
       total += -r[i]*Math.sin(Math.sqrt(Math.abs(r[i])));
    }
    total += 418.9829*dimension + total;
    return total;
 }   


 private double rosenbrock(double[] present) {
    /* X=[-2.048,2.048] or X=[-30,30]*/   
    double total = 0;

    for(int i = 0; i < dimension-1; i++)
    {
       total += (1-present[i])*(1-present[i]) + 100.0*(present[i+1]-present[i]*present[i])*(present[i+1]-present[i]*present[i]);
    }       
    return total;
 } 

 private double rrosenbrock(double[] present) {
    /* X=[-2.048,2.048] or X=[-30,30]*/
    double[] r = new double[dimension];
    for(int i = 0; i < dimension; i++)
        r[i] = 0.0;
    
    double[][] rotmat = getRotationMatrix();

    for(int i = 0; i < dimension; i++)
    {
       for(int j = 0; j < dimension; j++)
          r[i] += rotmat[i][j]*(present[j]);
    }
     
    double total = 0;

    for(int i = 0; i < dimension-1; i++)
    {
       total += (1-r[i])*(1-r[i]) + 100.0*(r[i+1]-r[i]*r[i])*(r[i+1]-r[i]*r[i]);
    }       
    return total;
 } 


 private double quadric(double[] present) {
    /* X=[-100,100] */   
    double total1 = 0;
    double total2 = 0;

    for(int i = 0; i < dimension; i++)
    {
        total1 = 0;
        for(int j = 0; j < i; j++)
            total1 += present[j];
        total1 *= total1;
        total2 += total1;
    }       
    return total2;
 } 

 private double rquadric(double[] present) {
    /* X=[-100,100] */
    double[] r = new double[dimension];
    for(int i = 0; i < dimension; i++)
        r[i] = 0.0;
    
    double[][] rotmat = getRotationMatrix();

    for(int i = 0; i < dimension; i++)
    {
       for(int j = 0; j < dimension; j++)
          r[i] += rotmat[i][j]*(present[j]);
    }

    double total1 = 0;
    double total2 = 0;

    for(int i = 0; i < dimension; i++)
    {
        total1 = 0;
        for(int j = 0; j < i; j++)
            total1 += r[j];
        total1 *= total1;
        total2 += total1;
    }       
    return total2;
 } 


private double rhyperellipsoid(double[] present) {
    /* X=[-100,100] */
    double[] r = new double[dimension];
    for(int i = 0; i < dimension; i++)
        r[i] = 0.0;
    
    double[][] rotmat = getRotationMatrix();

    for(int i = 0; i < dimension; i++)
    {
       for(int j = 0; j < dimension; j++)
          r[i] += rotmat[i][j]*(present[j]);
    }
     
    double total = 0;

    for(int i = 0; i < dimension; i++)
       total += Math.pow(2.0,i)*(r[i]-10)*(r[i]-10);
       
    return total;
 } 

private double hyperellipsoid(double[] present) {
    /* X=[-100,100] */     
    double total = 0;

    for(int i = 0; i < dimension; i++)
       total += Math.pow(2.0,i)*(present[i]-2)*(present[i]-2);

    return total;
 } 


/************************************************ 
 * CEC'08 Large scale optimization test functions
 ************************************************/

  private double shiftedSphere(int dim, double[] x) {
    int i;
    double z;
    double F = 0;
    for(i=0;i<dim;i++){
        z = x[i] - Data.sphere[i];
        F += z*z;
    }
    return F + Data.f_bias[0];    
  }

  private double schwefelProblem( int dim , double[] x){
    int i;
    double z;
    double F = Math.abs(x[0]);
    for(i=1;i<dim;i++){
          z = x[i] - Data.schwefel[i];
        F = Math.max(F , Math.abs(z));
    }
    return F + Data.f_bias[1]; 
}

 private double shiftedRosenbrock( int dim , double[] x ){
    int i;
    double[] z = new double[dim];
    double F = 0;

    for(i=0;i<dim;i++) z[i] = x[i] - Data.rosenbrock[i] + 1;   

    for(i=0;i<dim-1;i++){    
        F = F + 100*( Math.pow((Math.pow(z[i],2)-z[i+1]) , 2) ) + Math.pow((z[i]-1) , 2);
    }
    return F + Data.f_bias[2]; 
}

private double shiftedRotatedRosenbrock(int dim, double[] x) 
{
    double[] r = new double[dim];
    for(int i = 0; i < dim; i++)
    r[i] = 0.0;
    
    double[][] rotmat = getRotationMatrix();
    for(int i = 0; i < dim; i++)
    {
       for(int j = 0; j < dim; j++)
          r[i] += rotmat[i][j]*(x[j] - Data.rosenbrock[j]);
    }

    int i;
    double[] z = new double[dim];
    double F = 0;

    for(i=0;i<dim;i++) z[i] = r[i] + 1;   

    for(i=0;i<dim-1;i++){    
        F = F + 100*( Math.pow((Math.pow(z[i],2)-z[i+1]) , 2) ) + Math.pow((z[i]-1) , 2);
    }
    //System.out.println("F: "+F);
    return F + Data.f_bias[2];
}

private double shiftedRastrigin( int dim , double[] x )
{
    int i;
    double z;
    double F = 0;
    for(i=0;i<dim;i++){  
        z = x[i] - Data.rastrigin[i];
        F = F + ( Math.pow(z,2) - 10*Math.cos(2*Math.PI*z) + 10);
    }
    return F + Data.f_bias[3]; 
}

private double shiftedRotatedRastrigin(int dim, double[] x) 
{
    double[] r = new double[dim];
    for(int i = 0; i < dim; i++)
    r[i] = 0.0;
    
    double[][] rotmat = getRotationMatrix();
    for(int i = 0; i < dim; i++)
    {
       for(int j = 0; j < dim; j++)
          r[i] += rotmat[i][j]*(x[j] - Data.rastrigin[j]);
    }

    double z;
    double F = 0;
    for(int i=0;i<dim;i++){  
        z = r[i];
        F = F + ( Math.pow(z,2) - 10*Math.cos(2*Math.PI*z) + 10);
    }
    return F + Data.f_bias[3]; 
}


private double shiftedGriewank( int dim , double[] x ){
    int i;
    double z;
    double F1 = 0;
    double F2 = 1;
    for(i=0;i<dim;i++){       
        z = x[i] - Data.griewank[i];
        F1 = F1 + ( Math.pow(z,2) / 4000 );
        F2 = F2 * ( Math.cos(z/Math.sqrt(i+1)));

    }
    return (F1 - F2 + 1 + Data.f_bias[4]); 
}

private double shiftedRotatedGriewank(int dim, double[] x) 
{
    double[] r = new double[dim];
    for(int i = 0; i < dim; i++)
    r[i] = 0.0;
    
    double[][] rotmat = getRotationMatrix();
    for(int i = 0; i < dim; i++)
    {
       for(int j = 0; j < dim; j++)
          r[i] += rotmat[i][j]*(x[j] - Data.griewank[j]);
    }

    int i;
    double z;
    double F1 = 0;
    double F2 = 1;
    for(i=0;i<dim;i++){       
        z = r[i];
        F1 = F1 + ( Math.pow(z,2) / 4000 );
        F2 = F2 * ( Math.cos(z/Math.sqrt(i+1)));

    }
    return (F1 - F2 + 1 + Data.f_bias[4]); 
}


private double shiftedAckley( int dim , double[] x ){
    int i;
    double z;
    double Sum1 = 0;
    double Sum2 = 0;
    double F = 0;
    for(i=0;i<dim;i++){   
        z = x[i] - Data.ackley[i];
        Sum1 = Sum1 + Math.pow(z , 2 );
        Sum2 = Sum2 + Math.cos(2*Math.PI*z);
    }
    F = -20*Math.exp(-0.2*Math.sqrt(Sum1/dim)) -Math.exp(Sum2/dim) + 20 + Math.E + Data.f_bias[5];

    return F; 
}

private double shiftedRotatedAckley(int dim, double[] x) 
{
    double[] r = new double[dim];
    for(int i = 0; i < dim; i++)
    r[i] = 0.0;
    
    double[][] rotmat = getRotationMatrix();
    for(int i = 0; i < dim; i++)
    {
       for(int j = 0; j < dim; j++)
          r[i] += rotmat[i][j]*(x[j] - Data.ackley[j]);
    }

    int i;
    double z;
    double Sum1 = 0;
    double Sum2 = 0;
    double F = 0;
    for(i=0;i<dim;i++){   
        z = r[i];
        Sum1 = Sum1 + Math.pow(z , 2 );
        Sum2 = Sum2 + Math.cos(2*Math.PI*z);
    }
    F = -20*Math.exp(-0.2*Math.sqrt(Sum1/dim)) -Math.exp(Sum2/dim) + 20 + Math.E + Data.f_bias[5];

    return F;
}


/************* end of test functions *************/ 
 
  /**
   * Get init parameters
   * @return
   */
  public String[] getInitParam() {
    String[] params =  {"numParticles", "velocityMax", "maxIterations", "maxNumEvals", "numSwarms",
            "dimension", "BATCH", "RGROUPING", "OUTGBEST", "ROTATIONFLAG", "RESIZE", "ADAPTIVEGROUPSIZE","GROUPBYDELTA", "function", "method", "resizeIters"};
    return params;
  }

   public static void main (String[] args) {
    SimInit init = new SimInit();
   
    PSOModel model = new PSOModel();
    init.loadModel(model,"",false);
    
  }

}
